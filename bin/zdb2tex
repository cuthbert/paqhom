#!/usr/bin/perl
#
# [2002-01-21, 17.58-21.12]
#
# [2002-01-22, 07.29-14.37]
#
# [2002-01-25,~19.00-19.44] Now ZDb is specified on command line, instead of
# hardcoded. Also LaTeXifies the $extra field (previously the hyphen did not
# get translated into a correct LaTeX hyphen (i.e. minus) which resulted in an
# ugly black square instead. (This occured once in the dictionary.)
#
# [2010-05-11] Made it work with modern-day zdb, using unicode. Very
# rudimentary update, still up not to my current code standard
#
# [2010-05-13, 19:52-23:49] made to work with "use warnings" & "use stict";
# fixed proper identation; now accepts input on STDIN; started restructuring
# code by breaking it down into more easy-to-read subroutines; replaced old
# lower() function call with lc() (works fine with Swedish characters under
# modern Perl/UTF8); other minor cleanups
#
# [2010-05-17] used "perltidy" to clean up source code formatting

use strict;
use warnings;

# see open(3perl), encoding(3perl)
use encoding 'utf8';

# define alphabet
# string = regex that matches klingon letter
# array  = sort order
# hash   = letter to sort-letter
my $alpha = "(tlh|ch|gh|ng|[abDeHIjlmnopqQrStuvwy' ])";
my @alpha = (" ");                             # <space>
push @alpha, qw(a b ch D e gh H I j l m n ng o p q Q r S t tlh u v w y);
push @alpha, "'";
my $i;                                         # add glottal stop
my %alpha = ();
foreach (@alpha) { $alpha{$_} = chr 96 + $i++ }  # produce sort order hash

my $Fields = '^(tlh|en|def):\s*';              # fields we need
my $En_POS = '\((v|n|name|pro|adv|num|excl|ques|conj)\)';
#$Sv_POS = '\((v|s|namn|pro|adv|räkn|interj|fråg|konj)\)';

my $az = 'A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞ';
$az .= lc($az) . "ßÿ";

my $direction  = "";
my %directions = (
    "en-tlh" => "English-Klingon",
    "tlh-en" => "Klingon-English",
    #"sv-tlh" => "Swedish-Klingon",
    #"tlh-sv" => "Klingon-Swedish",
);

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub latex_header {
    my ($direction, $words) = @_;
    return
      "% -*- tex -*-\n",
      "%\n",
      "% $directions{$direction} dictionary.\n",
      "% LaTeX conversion started: " . `date +"%Y-%m-%d, %H.%m.%S"`,
      "% There are $words words in this file.\n\n";
}

sub latex_footer {
    my ($direction, $words) = @_;
    return
      "% LaTeX conversion ended: " . `date +"%Y-%m-%d, %H.%m.%S"`,
      "% [eof]\n";
}

sub latexify {
    my ($x) = @_;
    foreach ($x) {
        s/{/\\B{/g;                            # bold    {...} => \B{...}
        s/~([^~]*)~/\\I{$1}/g;                 # italics ~...~ => \I{...}
        s/''/'{}'/g;                           # double aphostrophe
        s/(^| )\"/$1``/g;                      # initial quote
        s/\"/''/g;                             # ending quote
        s/\.\.\. /\ldots\ /g;                  # ... + <space>
        s/\.\.\./\ldots/g;                     # ...
        s/ /~/g;                               # non-breaking space
        s/¿?//g;                               # remove ¿?
        s/([%#\$])/\\$1/g;                     # escape %, #, $
    }
    return $x;
}

sub buffer_to_latex {
    my (@buf) = @_;                            # get buffer
    return unless @buf;                        # don't process empty buffers
    my (@return) = ();                         # reset returnbuffer

    # get fields
    my %field = ();                            # clear %field hash
    foreach (grep /$Fields/o, @buf) {
        s/$Fields//o;                          #   remove `xxx:\t'
        $field{$1} = $_;                       #   assign to %field
    }

    # process `tlh:'-field
    my $tlh = $field{tlh};
    $tlh =~ s/^{(.*)}.*/$1/;                   # remove all outside {...}
    $tlh = latexify($tlh);                     # LaTeXify

    # split `en:'-field into:
    #   `English', `part-of-speech' and `slang/regional'
    my $en = $field{en};
    $en =~ /(.*)$En_POS(.*)/;                  # fetch transl., pos & category
    ($en, my $pos, my $extra) = ($1, $2, $3);
    $en    =~ s/ *$//;                         # remove trailing space
    $extra =~ s/^\s*\((.*)\)\s*/$1/;           # remove surrounding parentheses
    $extra = latexify($extra);                 # LaTeXify

    # Klingon-English direction
    if ($direction =~ /^tlh-en/i) {
        #  #1 = Klingon (lookup) word
        #  #2 = part-of-speech
        #  #3 = 'slang' or 'regional' etc.
        #  #4 = English explanation of the word
        #  #5 = source
        #       (if Ø then source=TKD)

        # process `tlh:'-field
        $tlh =~ s/[<>«»]//g;                   # remove «»<> from klingon

        # process `def:'-field
        my $ref = $field{def};
        $ref =~ s/\[(.*)\]/$1/;                # remove brackets
        $ref =~ s/\s*\(.*\)//g;                # remove parentesis & contents
        $ref = "" if $ref eq "TKD";            # clear if "TKD"
        $ref = latexify($ref);                 # LaTeXify
        substr($ref, -6, 6) =~ s/ /~/g;        # no line break in end

        # process `en:'-field
        $en =~ s/[<>«»]//g;                    # remove «»<> from english
        {
            # if all english definitions begin with the word 'be'
            # and remove `be' in all but the first one if so
            (my $tmp = $en) =~ s/\(.*\)//g;    # disregard parenthesis cont
            $tmp = grep !/^be /,               # num of defs NOT beg with "be"
              split(', ', $tmp);
            if ($tmp == 0) {                   # all fields began with 'be'
                $en =~ s/, be /, /g;           # replace `, be ' with `, '
            }
        }
        $en = latexify($en);                   # LaTeXify
        my $off = -6 + length($ref);           # use non-breaking spaces
        substr($en, $off, 6) =~ s/ /~/g        #   at the end of english
          unless $off >= 0;                    #   definition

        # make sortkey
        my $sort = $field{tlh};
        $sort =~ s/[<>«»{}() ]//g;             # remove <space> <>«»{} and ()
        $sort =~ s/($alpha)/$alpha{$1}/g;      # translate
        $sort .= "_$pos";                      # attach part-of-speech
        $sort =~ s/([0-9])_(.*)/_$2_$1/;       # swap pos and lemma number

        push @return, "$sort \\lukli" .        # return value
          "{$tlh}{$pos}{$extra}{$en}{$ref}%\n";
    } else {
        # English-Klingon Direction
        #   #1 = English lookup word                (done)
        #   #2 = Klingon word                       (done)
        #   #3 = Part-of-speech                     (done)
        #   #4 = 'slang' or 'regional' etc.         (done)
        #   #5 = English explanation of the word
        #        (if Ø then the explanation equals the lookup word)
        #        (the lookup word is replaced by \lemma{}, which generates a tilde)

        # process `tlh:'-field
        $tlh =~ s/[<>«»]//g;                   # remove «»<> from klingon

        # extract all lookup words
        $en =~ tr/<>/«»/;                      # make <> into «»
        pos($en) = 0;
        my @stack = ();                        # init stack
        my $beg;
        while ($en =~ /«/g) {                  # find first `«'
            $beg = pos($en);                   # beg of this definiton
            push @stack, "»";                  # stack it
            my $len;
            do {                               # until stack is empty
                $en =~ /([«»])/g;              #   find next `«' or `»'
                if ($1 eq $stack[$#stack]) {   #   if equal to on stack
                    pop @stack;                #     pop it
                } else {                       #   otherwise
                    push @stack, "»";          #     push `»'
                }
                $len = pos($en) - $beg - 1;    #   length of lookup word
            } while @stack;
            my $lookup = substr($en, $beg, $len);  # lookup word
            $lookup =~ s/\s*\(.*\)//g;         # remove parentesis & contents

            # create sort string
            my $sort = $lookup;                # sort based on lookup word
            $sort =~ tr/«»<>{}~\' -//d;        # remove interpunct
            $sort = lc($sort);                 # make lowercase
            $sort =~ tr/àáâãäèéêëìíîïòóôõöùúûüýÿ/aaaaaeeeeiiiiooooouuuuyy/;
            $sort .= "_$pos";                  # attach part-of-speech
            (my $tmp = $tlh) =~ s/($alpha)/$alpha{$1}/g;

            # klingon sort word (useful for many similar words, e.g. bird)
            $sort .= "_$tmp";

            # lookup word
            $lookup =~ s/[<>«»]//g;            # remove «»<> from english
            $lookup = latexify($lookup);       # LaTeXify

            # English definition
            # ($xng temp for this loop, $en must be perserved)
            my $xng = $en;
            $xng =~ s/[<>«»]//g;               # remove «»<> from english
            $xng = latexify($xng);             # LaTeXify
            $xng = "" if ($xng eq $lookup);    # no def. if same as lookup

            # tilde implosion
            $xng =~ s{
                (?:^|(?<=[ ]))                 # space or beg-of-string
                \Q$lookup\E                    # lookup word
                (?=$|[, ])                     # end-of-string or
            }{×}gx;                            # tilde ("×") replacement

            # tilde removal (of parts w/ only tilde as transl.)
            $xng = join ', ', grep { !/^×$/ }  # remove all part-definitions
              split(', ', $xng);               #   containing only "×"

            # multiple `be' removal
            {
                # if all english definitions begin with the word 'be'
                # and remove `be' in all but the first one if so
                ($tmp = $xng) =~ s/\(.*\)//g;  # disregard parenthesis cont
                $tmp = grep !/^be /,
                  split(', ', $tmp);           # num of defs NOT beg with "be"
                if ($tmp == 0) {               # all fields began with 'be'
                    $xng =~ s/, be /, /g;      # replace `, be ' with `, '
                }
            }

            substr($xng, -6, 6) =~ s/ /~/g;    # nbsp at end of english
            $xng =~ s/×/\\lemma{}/g;           # special ~ comand

            push @return, "$sort \\lueng" .    # return value
              "{$lookup}{$tlh}{$pos}{$extra}{$xng}%\n";
        } continue {
            pos($en) = $beg;
        }
    } ## end else [ if ($direction =~ /^tlh-en/i)]
    return @return;
} ## end sub buffer_to_latex

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

if (@ARGV == 0 or grep(/^(-h|--help)$/, @ARGV)) {
    (my $self = $0) =~ s#^.*/##;
    print "Usage: $self DIRECTION [<] ZDBFILE\n";
    print "Extract contents of ZDBFILE(s) and output {paqHom} LaTeX source.\n";
    print "\n";
    print "Where DIRECTION is one of:\n";
    print "    $_  for $directions{$_} output\n" foreach sort keys %directions;
    print "\n";
    print "Input is read from ZDBFILE(s) or STDIN, output is sent to STDOUT.\n";
    exit;
}

$direction = shift();
if (not $directions{$direction}) {
    print "First argument must be one of:\n";
    print "    $_ -- for $directions{$_} output\n"
      foreach sort keys %directions;
    exit;
}

###############################################################################
##                                                                           ##
##  Main Program                                                             ##
##                                                                           ##
###############################################################################

# open file and skip header
while (<>) {                                   # skip past data file header
    last if /^=== start-of-word-list ===$/;
}

# read from the dictionary
my (@buf, @file) = ();
while (<>) {
    chomp;                                     # remove eol
    last if /^=== end-of-word-list ===$/;      # done at end-of-dict

    # beginning of a new post
    if (s/^(:|\s*$)//) {                       # beginning of new post?
        push @file, buffer_to_latex(@buf);     #   output processed buffer
        @buf = ();                             #   clear buffer
        next if /^$/;                          #   skip to next line in file
    }                                          #   if this one is empty now

    # add read line to buffer
    $buf[$#buf] .= $_, next if s/^\s+/ /;      # inital space: add to last line
    push @buf, $_;                             #   add a new line to buffer
}

# output main body of file
print latex_header($direction, $#file + 1);
my ($oldfirst, $first) = ("", "");
foreach (sort @file) {
    ($first) = /^(.)/;                         # get sortstring's 1st letter
    print "\\newletter{}%\n"                   # new letter in alphabet
      if $first ne $oldfirst;
    s/[^ ]* //;                                # remove sortstring
    print "  $_";                              # output
} continue {
    $oldfirst = $first;
}                                              # remember 1st letter
print latex_footer();

#[eof]
